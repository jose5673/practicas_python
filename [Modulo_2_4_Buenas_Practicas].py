"""
üéØ M√ìDULO 2.4: BUENAS PR√ÅCTICAS Y ORGANIZACI√ìN DE C√ìDIGO
üìö PYTHON PARA AUTOMATIZACI√ìN INDUSTRIAL
=====================================================

üìã OBJETIVOS DE APRENDIZAJE:
‚Ä¢ Dominar las convenciones de c√≥digo Python (PEP 8)
‚Ä¢ Estructurar c√≥digo de forma legible y mantenible
‚Ä¢ Aplicar principios SOLID en programaci√≥n Python
‚Ä¢ Gestionar configuraciones y variables de entorno
‚Ä¢ Implementar logging profesional para sistemas industriales
‚Ä¢ Crear documentaci√≥n t√©cnica efectiva
‚Ä¢ Aplicar testing b√°sico para validar c√≥digo

üéØ PROYECTO DEL M√ìDULO: Sistema de monitoreo modular y bien estructurado

‚ö†Ô∏è  ADVERTENCIA CR√çTICA:
En automatizaci√≥n industrial, el c√≥digo mal estructurado puede causar fallos
cr√≠ticos en producci√≥n. Las buenas pr√°cticas no son opcionales, son VITALES.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 1: CONVENCIONES DE C√ìDIGO - PEP 8
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üîç PEP 8: LA BIBLIA DEL C√ìDIGO PYTHON

üè≠ ANALOG√çA INDUSTRIAL:
En una f√°brica, todos los operarios siguen procedimientos est√°ndar:
- Misma nomenclatura para herramientas
- Mismos protocolos de seguridad
- Misma documentaci√≥n de procesos

PEP 8 es el "procedimiento est√°ndar" para escribir c√≥digo Python.

üìä BENEFICIOS DE SEGUIR PEP 8:
‚úÖ C√≥digo m√°s legible y mantenible
‚úÖ Colaboraci√≥n eficiente en equipos
‚úÖ Reducci√≥n de errores por confusi√≥n
‚úÖ Facilita el debugging y troubleshooting
‚úÖ Est√°ndar reconocido mundialmente
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìù CONVENCIONES DE NOMENCLATURA
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# ‚ùå MAL - Nomenclatura inconsistente
temperaturaSensor = 25.5
Presion_Tanque = 1.2
VELOCIDAD_motor = 1800
def calculaEficiencia():
    pass

# ‚úÖ BIEN - Nomenclatura consistente y clara
temperatura_sensor = 25.5              # Variables: snake_case
presion_tanque = 1.2                   # Descriptivo y claro
VELOCIDAD_MAXIMA = 1800               # Constantes: UPPER_CASE

def calcular_eficiencia_motor():       # Funciones: snake_case + verbo
    """Calcula la eficiencia del motor basada en par√°metros operacionales."""
    pass

class SensorTemperatura:               # Clases: PascalCase
    """Clase para gestionar sensores de temperatura industriales."""
    pass

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìè FORMATO Y ESPACIADO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# ‚ùå MAL - Espaciado inconsistente
def procesar_datos(temp,presion,tiempo):
    if temp>50and presion<1.0:
        resultado=temp*presion+tiempo
        return resultado

# ‚úÖ BIEN - Espaciado consistente y legible
def procesar_datos_sensor(temperatura, presion, tiempo):
    """
    Procesa datos de sensores aplicando algoritmos de validaci√≥n.
    
    Args:
        temperatura (float): Temperatura en grados Celsius
        presion (float): Presi√≥n en bar
        tiempo (int): Timestamp Unix
        
    Returns:
        float: Valor procesado para el dashboard
    """
    # Validaci√≥n de rangos cr√≠ticos
    if temperatura > 50 and presion < 1.0:
        # Aplicar correcci√≥n por temperatura alta y presi√≥n baja
        resultado = temperatura * presion + tiempo
        return resultado
    
    return 0.0

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üì¶ IMPORTS ORGANIZADOS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# ‚úÖ ORDEN CORRECTO DE IMPORTS
# 1. Librer√≠as est√°ndar de Python
import os
import sys
import json
from datetime import datetime, timedelta
from pathlib import Path

# 2. Librer√≠as de terceros
import requests
import pandas as pd
from flask import Flask, jsonify
from sqlalchemy import create_engine

# 3. M√≥dulos locales del proyecto
from src.modbus.client import ModbusClient
from src.database.models import SensorData
from src.utils.logger import setup_logger
from src.config.settings import DATABASE_URL

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 2: ESTRUCTURA DE C√ìDIGO MODULAR
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üèóÔ∏è PRINCIPIOS DE DISE√ëO MODULAR

üéØ PRINCIPIO DRY (Don't Repeat Yourself):
No repitas c√≥digo. Si lo escribes m√°s de una vez, cr√©a una funci√≥n.

üéØ PRINCIPIO SOLID (Responsabilidad √önica):
Cada funci√≥n/clase debe tener una sola responsabilidad clara.

üéØ SEPARACI√ìN DE RESPONSABILIDADES:
- Configuraci√≥n separada del c√≥digo
- L√≥gica de negocio separada de la presentaci√≥n
- Datos separados del procesamiento
"""

# ‚úÖ EJEMPLO: CLASE BIEN ESTRUCTURADA
class SensorManager:
    """
    Gestor centralizado para operaciones con sensores industriales.
    
    Responsabilidades:
    - Conexi√≥n con dispositivos Modbus
    - Validaci√≥n de datos de entrada
    - Almacenamiento en base de datos
    - Generaci√≥n de alertas
    """
    
    def __init__(self, config_path: str):
        """
        Inicializa el gestor de sensores.
        
        Args:
            config_path (str): Ruta al archivo de configuraci√≥n
        """
        self.config = self._load_config(config_path)
        self.logger = setup_logger('SensorManager')
        self.db_engine = self._setup_database()
        self.modbus_client = None
        
    def _load_config(self, config_path: str) -> dict:
        """Carga configuraci√≥n desde archivo JSON."""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            self.logger.error(f"Archivo de configuraci√≥n no encontrado: {config_path}")
            raise
        except json.JSONDecodeError as e:
            self.logger.error(f"Error al parsear configuraci√≥n: {e}")
            raise
            
    def _setup_database(self):
        """Configura conexi√≥n a base de datos."""
        try:
            engine = create_engine(self.config['database']['url'])
            self.logger.info("Conexi√≥n a base de datos establecida")
            return engine
        except Exception as e:
            self.logger.error(f"Error conectando a base de datos: {e}")
            raise
            
    def connect_modbus(self) -> bool:
        """
        Establece conexi√≥n con dispositivo Modbus.
        
        Returns:
            bool: True si la conexi√≥n es exitosa
        """
        try:
            self.modbus_client = ModbusClient(
                host=self.config['modbus']['host'],
                port=self.config['modbus']['port']
            )
            
            if self.modbus_client.connect():
                self.logger.info("Conexi√≥n Modbus establecida")
                return True
            else:
                self.logger.error("Fallo en conexi√≥n Modbus")
                return False
                
        except Exception as e:
            self.logger.error(f"Error en conexi√≥n Modbus: {e}")
            return False
            
    def read_sensor_data(self, sensor_address: int) -> dict:
        """
        Lee datos de un sensor espec√≠fico.
        
        Args:
            sensor_address (int): Direcci√≥n Modbus del sensor
            
        Returns:
            dict: Datos del sensor con timestamp
        """
        if not self.modbus_client:
            raise ConnectionError("Cliente Modbus no conectado")
            
        try:
            # Leer registros del sensor
            raw_data = self.modbus_client.read_holding_registers(
                sensor_address, 
                count=4
            )
            
            # Procesar y validar datos
            processed_data = self._process_sensor_data(raw_data)
            
            # Agregar metadata
            sensor_data = {
                'sensor_id': sensor_address,
                'timestamp': datetime.utcnow().isoformat(),
                'temperatura': processed_data['temp'],
                'presion': processed_data['pressure'],
                'estado': processed_data['status']
            }
            
            # Validar rangos cr√≠ticos
            self._validate_sensor_ranges(sensor_data)
            
            return sensor_data
            
        except Exception as e:
            self.logger.error(f"Error leyendo sensor {sensor_address}: {e}")
            raise
            
    def _process_sensor_data(self, raw_data: list) -> dict:
        """Procesa datos crudos del sensor aplicando calibraciones."""
        return {
            'temp': raw_data[0] * 0.1,        # Factor de calibraci√≥n
            'pressure': raw_data[1] * 0.01,   # Conversi√≥n a bar
            'status': raw_data[2]             # Estado del sensor
        }
        
    def _validate_sensor_ranges(self, data: dict) -> None:
        """Valida que los datos est√©n en rangos operacionales."""
        temp_limits = self.config['sensor_limits']['temperature']
        pressure_limits = self.config['sensor_limits']['pressure']
        
        if not (temp_limits['min'] <= data['temperatura'] <= temp_limits['max']):
            self.logger.warning(
                f"Temperatura fuera de rango: {data['temperatura']}¬∞C"
            )
            
        if not (pressure_limits['min'] <= data['presion'] <= pressure_limits['max']):
            self.logger.warning(
                f"Presi√≥n fuera de rango: {data['presion']} bar"
            )

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 3: GESTI√ìN DE CONFIGURACI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üîß GESTI√ìN PROFESIONAL DE CONFIGURACI√ìN

üéØ PRINCIPIOS:
1. Nunca hardcodear valores en el c√≥digo
2. Usar archivos de configuraci√≥n externos
3. Variables de entorno para datos sensibles
4. Configuraciones diferentes para dev/test/prod
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# config/development.py
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class DevelopmentConfig:
    """Configuraci√≥n para entorno de desarrollo."""
    
    # Base de datos local
    DATABASE_URL = "sqlite:///dev_automation.db"
    
    # Modbus simulator para desarrollo
    MODBUS_HOST = "localhost"
    MODBUS_PORT = 5020
    
    # Logging detallado para debugging
    LOG_LEVEL = "DEBUG"
    LOG_FILE = "logs/development.log"
    
    # Intervalos de lectura r√°pidos para testing
    SENSOR_POLL_INTERVAL = 1.0  # segundos
    
    # Modo debug activado
    DEBUG = True
    TESTING = False

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# config/production.py
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import os
from dotenv import load_dotenv

load_dotenv()

class ProductionConfig:
    """Configuraci√≥n para entorno de producci√≥n."""
    
    # Base de datos industrial (desde variable de entorno)
    DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://user:pass@localhost/automation')
    
    # PLC real en red industrial
    MODBUS_HOST = os.getenv('PLC_HOST', '192.168.1.100')
    MODBUS_PORT = int(os.getenv('PLC_PORT', '502'))
    
    # Logging optimizado para producci√≥n
    LOG_LEVEL = "INFO"
    LOG_FILE = "/var/log/automation/production.log"
    
    # Intervalos optimizados para eficiencia
    SENSOR_POLL_INTERVAL = 5.0  # segundos
    
    # Seguridad m√°xima
    DEBUG = False
    TESTING = False
    
    # Configuraciones de red industrial
    NETWORK_TIMEOUT = 10.0
    RETRY_ATTEMPTS = 3
    
    # L√≠mites operacionales
    SENSOR_LIMITS = {
        'temperature': {'min': -10, 'max': 80},
        'pressure': {'min': 0.5, 'max': 5.0},
        'humidity': {'min': 20, 'max': 80}
    }

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# src/utils/config.py - Gestor de configuraci√≥n
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def get_config():
    """
    Retorna la configuraci√≥n apropiada seg√∫n el entorno.
    
    Returns:
        Config: Clase de configuraci√≥n correspondiente
    """
    env = os.getenv('FLASK_ENV', 'development')
    
    if env == 'production':
        from config.production import ProductionConfig
        return ProductionConfig()
    elif env == 'testing':
        from config.testing import TestingConfig
        return TestingConfig()
    else:
        from config.development import DevelopmentConfig
        return DevelopmentConfig()

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 4: LOGGING PROFESIONAL
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üìä LOGGING PARA SISTEMAS INDUSTRIALES

üéØ NIVELES DE LOGGING:
- DEBUG: Informaci√≥n detallada para desarrollo
- INFO: Informaci√≥n general del funcionamiento
- WARNING: Situaciones que requieren atenci√≥n
- ERROR: Errores que afectan funcionalidad
- CRITICAL: Errores cr√≠ticos que requieren intervenci√≥n inmediata

üè≠ EN AUTOMATIZACI√ìN INDUSTRIAL:
- Los logs son evidencia de lo que pas√≥ en el sistema
- Pueden ser requeridos para auditor√≠as
- Ayudan a diagnosticar fallos en producci√≥n
- Son cr√≠ticos para el mantenimiento predictivo
"""

import logging
import logging.handlers
from pathlib import Path
from datetime import datetime

def setup_industrial_logger(name: str, config) -> logging.Logger:
    """
    Configura logger profesional para sistemas industriales.
    
    Args:
        name (str): Nombre del logger
        config: Objeto de configuraci√≥n
        
    Returns:
        logging.Logger: Logger configurado
    """
    logger = logging.getLogger(name)
    logger.setLevel(getattr(logging, config.LOG_LEVEL))
    
    # Evitar duplicar handlers
    if logger.handlers:
        return logger
    
    # Crear directorio de logs si no existe
    log_dir = Path(config.LOG_FILE).parent
    log_dir.mkdir(parents=True, exist_ok=True)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # FORMATTER - Formato industrial con informaci√≥n cr√≠tica
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    formatter = logging.Formatter(
        fmt='%(asctime)s | %(levelname)-8s | %(name)-15s | '
            'PID:%(process)d | %(funcName)-20s | L%(lineno)-4d | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # FILE HANDLER - Rotaci√≥n autom√°tica para evitar archivos gigantes
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    file_handler = logging.handlers.RotatingFileHandler(
        filename=config.LOG_FILE,
        maxBytes=10 * 1024 * 1024,  # 10 MB por archivo
        backupCount=10,              # Mantener 10 archivos de respaldo
        encoding='utf-8'
    )
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.DEBUG)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # CONSOLE HANDLER - Solo para desarrollo y errores cr√≠ticos
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    console_handler = logging.StreamHandler()
    console_formatter = logging.Formatter(
        '%(levelname)-8s | %(name)-15s | %(message)s'
    )
    console_handler.setFormatter(console_formatter)
    
    # En producci√≥n, solo mostrar errores en consola
    if config.DEBUG:
        console_handler.setLevel(logging.DEBUG)
    else:
        console_handler.setLevel(logging.ERROR)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # SYSLOG HANDLER - Para sistemas cr√≠ticos en producci√≥n
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    if not config.DEBUG:
        try:
            syslog_handler = logging.handlers.SysLogHandler(
                address=('localhost', 514)
            )
            syslog_formatter = logging.Formatter(
                'AutomationSystem[%(process)d]: %(levelname)s %(name)s %(message)s'
            )
            syslog_handler.setFormatter(syslog_formatter)
            syslog_handler.setLevel(logging.WARNING)
            logger.addHandler(syslog_handler)
        except:
            # Si syslog no est√° disponible, continuar sin √©l
            pass
    
    # Agregar handlers al logger
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    # Log inicial
    logger.info(f"Logger '{name}' inicializado correctamente")
    logger.info(f"Archivo de log: {config.LOG_FILE}")
    logger.debug(f"Nivel de logging: {config.LOG_LEVEL}")
    
    return logger

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# EJEMPLO DE USO DE LOGGING EN CLASE INDUSTRIAL
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class PLCController:
    """Controlador para comunicaci√≥n con PLC industrial."""
    
    def __init__(self, config):
        self.config = config
        self.logger = setup_industrial_logger('PLCController', config)
        self.connection = None
        
    def connect(self) -> bool:
        """Establece conexi√≥n con el PLC."""
        self.logger.info(f"Intentando conectar a PLC en {self.config.MODBUS_HOST}:{self.config.MODBUS_PORT}")
        
        try:
            # Simular conexi√≥n
            if self.config.DEBUG:
                self.logger.debug("Modo DEBUG: Simulando conexi√≥n exitosa")
                self.connection = "SIMULATED"
            else:
                # Aqu√≠ ir√≠a la conexi√≥n real
                pass
                
            self.logger.info("‚úÖ Conexi√≥n PLC establecida exitosamente")
            return True
            
        except ConnectionError as e:
            self.logger.error(f"‚ùå Error de conexi√≥n PLC: {e}")
            return False
        except Exception as e:
            self.logger.critical(f"üö® Error cr√≠tico en conexi√≥n PLC: {e}")
            raise
            
    def read_sensor(self, sensor_id: int) -> dict:
        """Lee datos de un sensor espec√≠fico."""
        self.logger.debug(f"Leyendo sensor ID: {sensor_id}")
        
        if not self.connection:
            self.logger.warning("‚ö†Ô∏è Intento de lectura sin conexi√≥n establecida")
            raise ConnectionError("PLC no conectado")
            
        try:
            # Simular lectura de datos
            sensor_data = {
                'id': sensor_id,
                'value': 25.5,
                'status': 'OK',
                'timestamp': datetime.now().isoformat()
            }
            
            self.logger.debug(f"Datos del sensor {sensor_id}: {sensor_data}")
            
            # Validar datos cr√≠ticos
            if sensor_data['value'] > 50:
                self.logger.warning(f"‚ö†Ô∏è Temperatura alta en sensor {sensor_id}: {sensor_data['value']}¬∞C")
            
            return sensor_data
            
        except Exception as e:
            self.logger.error(f"‚ùå Error leyendo sensor {sensor_id}: {e}")
            raise

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 5: MANEJO DE ERRORES Y EXCEPCIONES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üö® MANEJO ROBUSTO DE ERRORES

En sistemas industriales, los errores no son opcionales de manejar.
Un error no controlado puede:
- Parar una l√≠nea de producci√≥n
- Causar p√©rdidas econ√≥micas
- Crear situaciones de riesgo

üéØ ESTRATEGIAS:
1. Anticipar todos los posibles errores
2. Categorizar errores por severidad
3. Definir acciones de recuperaci√≥n
4. Documentar todos los errores
5. Implementar fallbacks y redundancia
"""

# Excepciones personalizadas para el dominio industrial
class IndustrialSystemError(Exception):
    """Excepci√≥n base para errores del sistema industrial."""
    pass

class PLCConnectionError(IndustrialSystemError):
    """Error espec√≠fico de conexi√≥n con PLC."""
    pass

class SensorReadingError(IndustrialSystemError):
    """Error en lectura de sensores."""
    pass

class CriticalTemperatureError(IndustrialSystemError):
    """Error cr√≠tico de temperatura que requiere parada de emergencia."""
    pass

class DataValidationError(IndustrialSystemError):
    """Error en validaci√≥n de datos de sensores."""
    pass

# Ejemplo de manejo robusto de errores
class RobustSensorReader:
    """Lector de sensores con manejo robusto de errores."""
    
    def __init__(self, config):
        self.config = config
        self.logger = setup_industrial_logger('SensorReader', config)
        self.retry_count = 0
        self.max_retries = config.RETRY_ATTEMPTS
        
    def read_with_retry(self, sensor_id: int) -> dict:
        """
        Lee sensor con reintentos autom√°ticos y manejo de errores.
        
        Args:
            sensor_id (int): ID del sensor a leer
            
        Returns:
            dict: Datos del sensor o valores por defecto
            
        Raises:
            CriticalTemperatureError: Si la temperatura es cr√≠tica
        """
        self.retry_count = 0
        
        while self.retry_count < self.max_retries:
            try:
                # Intentar lectura
                data = self._read_sensor_raw(sensor_id)
                
                # Validar datos cr√≠ticos
                self._validate_critical_data(data)
                
                # Reset contador si lectura exitosa
                if self.retry_count > 0:
                    self.logger.info(f"‚úÖ Lectura exitosa tras {self.retry_count} reintentos")
                    self.retry_count = 0
                    
                return data
                
            except PLCConnectionError as e:
                self.retry_count += 1
                self.logger.warning(
                    f"‚ö†Ô∏è Error conexi√≥n PLC (intento {self.retry_count}/{self.max_retries}): {e}"
                )
                
                if self.retry_count >= self.max_retries:
                    self.logger.error("‚ùå M√°ximos reintentos alcanzados - usando valores por defecto")
                    return self._get_default_sensor_data(sensor_id)
                    
                # Esperar antes del siguiente intento
                time.sleep(2 ** self.retry_count)  # Backoff exponencial
                
            except CriticalTemperatureError as e:
                # Error cr√≠tico - no reintentar, escalar inmediatamente
                self.logger.critical(f"üö® TEMPERATURA CR√çTICA - PARADA DE EMERGENCIA: {e}")
                self._trigger_emergency_stop()
                raise
                
            except DataValidationError as e:
                self.logger.error(f"‚ùå Error validaci√≥n datos sensor {sensor_id}: {e}")
                return self._get_default_sensor_data(sensor_id)
                
            except Exception as e:
                # Error inesperado
                self.logger.critical(f"üö® Error inesperado en sensor {sensor_id}: {e}")
                self.retry_count += 1
                
                if self.retry_count >= self.max_retries:
                    return self._get_default_sensor_data(sensor_id)
                    
    def _read_sensor_raw(self, sensor_id: int) -> dict:
        """Lectura cruda del sensor con posibilidad de errores."""
        # Simular diferentes tipos de errores para demostraci√≥n
        import random
        
        error_type = random.choice(['success', 'connection', 'validation', 'critical'])
        
        if error_type == 'connection':
            raise PLCConnectionError(f"No se puede conectar al sensor {sensor_id}")
        elif error_type == 'critical':
            raise CriticalTemperatureError(f"Temperatura cr√≠tica detectada: 95¬∞C")
        elif error_type == 'validation':
            raise DataValidationError(f"Datos inv√°lidos del sensor {sensor_id}")
        else:
            # Lectura exitosa
            return {
                'sensor_id': sensor_id,
                'temperature': 25.5,
                'pressure': 1.2,
                'timestamp': datetime.now().isoformat(),
                'status': 'OK'
            }
            
    def _validate_critical_data(self, data: dict) -> None:
        """Valida si los datos representan una situaci√≥n cr√≠tica."""
        temp = data.get('temperature', 0)
        
        if temp > 90:  # Temperatura cr√≠tica
            raise CriticalTemperatureError(f"Temperatura cr√≠tica: {temp}¬∞C")
            
        if temp < -20 or temp > 100:  # Fuera de rango f√≠sicamente posible
            raise DataValidationError(f"Temperatura fuera de rango v√°lido: {temp}¬∞C")
            
    def _get_default_sensor_data(self, sensor_id: int) -> dict:
        """Retorna datos por defecto cuando hay errores persistentes."""
        self.logger.warning(f"üîß Usando datos por defecto para sensor {sensor_id}")
        
        return {
            'sensor_id': sensor_id,
            'temperature': 20.0,  # Valor seguro por defecto
            'pressure': 1.0,      # Valor seguro por defecto  
            'timestamp': datetime.now().isoformat(),
            'status': 'DEFAULT_VALUE',
            'error': 'Sensor no disponible - usando valores por defecto'
        }
        
    def _trigger_emergency_stop(self) -> None:
        """Activa procedimientos de parada de emergencia."""
        self.logger.critical("üõë ACTIVANDO PARADA DE EMERGENCIA")
        
        # Aqu√≠ ir√≠a la l√≥gica real de parada de emergencia:
        # - Cerrar v√°lvulas
        # - Parar motores
        # - Activar alarmas
        # - Notificar al personal
        
        # Para demostraci√≥n, solo logging
        self.logger.critical("üõë Procedimientos de emergencia activados")

if __name__ == "__main__":
    # Ejemplo de uso del c√≥digo con buenas pr√°cticas
    from config.development import DevelopmentConfig
    
    print("üéØ DEMOSTRANDO BUENAS PR√ÅCTICAS DE C√ìDIGO")
    print("=" * 60)
    
    # Configuraci√≥n
    config = DevelopmentConfig()
    
    # Logger
    logger = setup_industrial_logger('Main', config)
    logger.info("üöÄ Iniciando demostraci√≥n de buenas pr√°cticas")
    
    # Sensor reader con manejo robusto
    sensor_reader = RobustSensorReader(config)
    
    # Leer varios sensores
    for sensor_id in [1, 2, 3]:
        try:
            data = sensor_reader.read_with_retry(sensor_id)
            logger.info(f"‚úÖ Sensor {sensor_id}: {data['temperature']}¬∞C")
        except CriticalTemperatureError:
            logger.error(f"‚ùå Sensor {sensor_id}: PARADA DE EMERGENCIA")
            break
        except Exception as e:
            logger.error(f"‚ùå Error inesperado con sensor {sensor_id}: {e}")
    
    logger.info("üéØ Demostraci√≥n completada")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 6: TESTING Y VALIDACI√ìN DE C√ìDIGO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üß™ TESTING EN SISTEMAS INDUSTRIALES

üéØ ¬øPOR QU√â TESTING ES CR√çTICO EN AUTOMATIZACI√ìN?
- Un error en producci√≥n puede costar millones
- Sistemas industriales deben funcionar 24/7
- Vidas humanas pueden depender del c√≥digo
- Cumplimiento de normativas y auditor√≠as

üè≠ ANALOG√çA INDUSTRIAL:
En una f√°brica, cada componente se prueba antes de instalaci√≥n:
- Motores se prueban en banco de pruebas
- Sensores se calibran en laboratorio
- Sistemas se validan en ambiente controlado

El testing es el "banco de pruebas" para nuestro c√≥digo.
"""

import pytest
import unittest
from unittest.mock import Mock, patch, MagicMock

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# UNIT TESTS - Pruebas Unitarias
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TestSensorManager(unittest.TestCase):
    """Tests unitarios para la clase SensorManager."""
    
    def setUp(self):
        """Configuraci√≥n inicial para cada test."""
        self.config_mock = {
            'database': {'url': 'sqlite:///:memory:'},
            'modbus': {'host': 'localhost', 'port': 502},
            'sensor_limits': {
                'temperature': {'min': -10, 'max': 80},
                'pressure': {'min': 0.5, 'max': 5.0}
            }
        }
        
    @patch('builtins.open')
    @patch('json.load')
    def test_load_config_success(self, mock_json_load, mock_open):
        """Test: Carga exitosa de configuraci√≥n."""
        # Arrange
        mock_json_load.return_value = self.config_mock
        
        # Act
        sensor_manager = SensorManager.__new__(SensorManager)
        config = sensor_manager._load_config('test_config.json')
        
        # Assert
        self.assertEqual(config, self.config_mock)
        mock_open.assert_called_once_with('test_config.json', 'r', encoding='utf-8')
    
    def test_process_sensor_data_calibration(self):
        """Test: Calibraci√≥n correcta de datos del sensor."""
        # Arrange
        sensor_manager = SensorManager.__new__(SensorManager)
        raw_data = [255, 150, 1]  # Datos crudos del sensor
        
        # Act
        processed = sensor_manager._process_sensor_data(raw_data)
        
        # Assert
        expected = {
            'temp': 25.5,      # 255 * 0.1
            'pressure': 1.5,   # 150 * 0.01  
            'status': 1
        }
        self.assertEqual(processed, expected)
    
    def test_validate_sensor_ranges_normal(self):
        """Test: Validaci√≥n de datos en rango normal."""
        # Arrange
        sensor_manager = SensorManager.__new__(SensorManager)
        sensor_manager.config = self.config_mock
        sensor_manager.logger = Mock()
        
        data = {'temperatura': 25.0, 'presion': 2.0}
        
        # Act & Assert (no debe lanzar excepci√≥n ni generar warnings)
        sensor_manager._validate_sensor_ranges(data)
        sensor_manager.logger.warning.assert_not_called()
    
    def test_validate_sensor_ranges_out_of_bounds(self):
        """Test: Validaci√≥n de datos fuera de rango."""
        # Arrange
        sensor_manager = SensorManager.__new__(SensorManager)
        sensor_manager.config = self.config_mock
        sensor_manager.logger = Mock()
        
        data = {'temperatura': 90.0, 'presion': 6.0}  # Fuera de rango
        
        # Act
        sensor_manager._validate_sensor_ranges(data)
        
        # Assert
        self.assertEqual(sensor_manager.logger.warning.call_count, 2)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# INTEGRATION TESTS - Pruebas de Integraci√≥n
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class TestRobustSensorReaderIntegration(unittest.TestCase):
    """Tests de integraci√≥n para el lector robusto de sensores."""
    
    def setUp(self):
        """Setup para tests de integraci√≥n."""
        self.config = DevelopmentConfig()
        self.sensor_reader = RobustSensorReader(self.config)
    
    @patch('random.choice')
    def test_successful_sensor_reading_integration(self, mock_random):
        """Test: Lectura exitosa de sensor en flujo completo."""
        # Arrange
        mock_random.return_value = 'success'
        
        # Act
        result = self.sensor_reader.read_with_retry(1)
        
        # Assert
        self.assertIsInstance(result, dict)
        self.assertIn('sensor_id', result)
        self.assertIn('temperature', result)
        self.assertIn('timestamp', result)
        self.assertEqual(result['status'], 'OK')
    
    @patch('random.choice')
    def test_retry_mechanism_integration(self, mock_random):
        """Test: Mecanismo de reintentos en acci√≥n."""
        # Arrange - Simular 2 fallos seguidos de √©xito
        mock_random.side_effect = ['connection', 'connection', 'success']
        
        # Act
        result = self.sensor_reader.read_with_retry(2)
        
        # Assert
        self.assertIsInstance(result, dict)
        self.assertEqual(result['status'], 'OK')
    
    @patch('random.choice')
    def test_critical_temperature_handling(self, mock_random):
        """Test: Manejo de temperatura cr√≠tica."""
        # Arrange
        mock_random.return_value = 'critical'
        
        # Act & Assert
        with self.assertRaises(CriticalTemperatureError):
            self.sensor_reader.read_with_retry(3)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# MOCKING PARA SISTEMAS EXTERNOS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class MockModbusClient:
    """Mock de cliente Modbus para testing sin hardware real."""
    
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connected = False
        
    def connect(self):
        """Simula conexi√≥n exitosa."""
        self.connected = True
        return True
        
    def read_holding_registers(self, address, count):
        """Simula lectura de registros Modbus."""
        if not self.connected:
            raise PLCConnectionError("Cliente no conectado")
            
        # Simular datos realistas seg√∫n la direcci√≥n
        if address == 1:
            return [250, 120, 1, 0]  # Sensor temperatura normal
        elif address == 2:
            return [950, 300, 1, 0]  # Sensor con temperatura cr√≠tica
        else:
            return [200, 100, 0, 1]  # Sensor con error

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PERFORMANCE TESTS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import time
import statistics

def test_sensor_reading_performance():
    """Test de rendimiento para lectura masiva de sensores."""
    config = DevelopmentConfig()
    sensor_reader = RobustSensorReader(config)
    
    # Medir tiempo de 100 lecturas
    times = []
    
    for i in range(100):
        start_time = time.time()
        try:
            # Simular lectura exitosa
            with patch('random.choice', return_value='success'):
                sensor_reader.read_with_retry(i % 10)
        except:
            pass
        end_time = time.time()
        times.append(end_time - start_time)
    
    # An√°lisis de performance
    avg_time = statistics.mean(times)
    max_time = max(times)
    min_time = min(times)
    
    print(f"\nüìä AN√ÅLISIS DE PERFORMANCE:")
    print(f"‚è±Ô∏è Tiempo promedio: {avg_time:.4f}s")
    print(f"‚è±Ô∏è Tiempo m√°ximo: {max_time:.4f}s") 
    print(f"‚è±Ô∏è Tiempo m√≠nimo: {min_time:.4f}s")
    
    # Aserciones de performance
    assert avg_time < 0.1, f"Performance degradada: {avg_time:.4f}s > 0.1s"
    assert max_time < 0.5, f"Tiempo m√°ximo excesivo: {max_time:.4f}s > 0.5s"

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 7: DOCUMENTACI√ìN T√âCNICA PROFESIONAL
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üìö DOCUMENTACI√ìN EN AUTOMATIZACI√ìN INDUSTRIAL

üéØ TIPOS DE DOCUMENTACI√ìN REQUERIDA:
1. Documentaci√≥n de c√≥digo (docstrings, comentarios)
2. Documentaci√≥n de arquitectura
3. Manuales de usuario/operador
4. Documentaci√≥n de APIs
5. Diagramas de sistema
6. Procedimientos de mantenimiento

üè≠ EST√ÅNDARES INDUSTRIALES:
- ISO 9001 (Calidad)
- IEC 61131 (PLCs)  
- ISA-95 (Integraci√≥n Empresarial)
- 21 CFR Part 11 (FDA - Industria Farmac√©utica)
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# DOCSTRINGS INDUSTRIALES COMPLETOS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class IndustrialDocumentationExample:
    """
    Ejemplo de documentaci√≥n completa para clase industrial.
    
    Esta clase demuestra c√≥mo documentar adecuadamente c√≥digo para
    sistemas de automatizaci√≥n industrial, siguiendo est√°ndares
    profesionales y mejores pr√°cticas.
    
    Attributes:
        device_id (str): Identificador √∫nico del dispositivo
        ip_address (str): Direcci√≥n IP del dispositivo en red industrial
        port (int): Puerto de comunicaci√≥n Modbus TCP
        timeout (float): Timeout de comunicaci√≥n en segundos
        retry_attempts (int): N√∫mero m√°ximo de reintentos
        
    Note:
        Esta clase est√° dise√±ada para entornos industriales donde
        la confiabilidad y trazabilidad son cr√≠ticas.
        
    Warning:
        Modificaciones a esta clase pueden afectar sistemas cr√≠ticos.
        Toda modificaci√≥n debe ser validada en ambiente de pruebas.
        
    Example:
        >>> device = IndustrialDocumentationExample(
        ...     device_id="PLC_001",
        ...     ip_address="192.168.1.100"
        ... )
        >>> device.connect()
        True
        >>> data = device.read_sensor(address=1)
        >>> print(data['temperature'])
        25.5
        
    Version:
        1.2.3 - Fecha: 2025-07-01
        
    Author:
        Equipo de Automatizaci√≥n Industrial
        
    Revision History:
        - v1.0.0 (2025-01-01): Versi√≥n inicial
        - v1.1.0 (2025-03-15): Agregado manejo de errores robusto
        - v1.2.0 (2025-06-01): Implementado logging profesional
        - v1.2.3 (2025-07-01): Corregido bug en reconexi√≥n autom√°tica
    """
    
    def __init__(self, device_id: str, ip_address: str, port: int = 502):
        """
        Inicializa dispositivo industrial con par√°metros de conexi√≥n.
        
        Args:
            device_id (str): Identificador √∫nico del dispositivo.
                Debe seguir nomenclatura: [TIPO]_[NUMERO]
                Ejemplos: "PLC_001", "HMI_002", "SENSOR_TEMP_015"
                
            ip_address (str): Direcci√≥n IP v√°lida del dispositivo.
                Debe estar en red industrial (t√≠picamente 192.168.x.x)
                
            port (int, optional): Puerto Modbus TCP. Defaults to 502.
                Rango v√°lido: 1-65535. Puerto 502 es est√°ndar Modbus.
                
        Raises:
            ValueError: Si device_id no sigue nomenclatura est√°ndar
            ValueError: Si ip_address no es IP v√°lida
            ValueError: Si port est√° fuera de rango v√°lido
            
        Note:
            La inicializaci√≥n no establece conexi√≥n autom√°ticamente.
            Llamar connect() despu√©s de crear la instancia.
            
        Example:
            >>> # Inicializaci√≥n correcta
            >>> device = IndustrialDocumentationExample(
            ...     device_id="PLC_LINEA_01", 
            ...     ip_address="192.168.10.100"
            ... )
            
            >>> # Inicializaci√≥n con puerto personalizado
            >>> device = IndustrialDocumentationExample(
            ...     device_id="HMI_SALA_CONTROL",
            ...     ip_address="192.168.10.200", 
            ...     port=5020
            ... )
        """
        # Validaciones de entrada
        self._validate_device_id(device_id)
        self._validate_ip_address(ip_address)
        self._validate_port(port)
        
        # Asignaci√≥n de atributos
        self.device_id = device_id
        self.ip_address = ip_address
        self.port = port
        
        # Configuraci√≥n por defecto
        self.timeout = 10.0
        self.retry_attempts = 3
        self.connected = False
        
        # Setup de logging espec√≠fico para el dispositivo
        self.logger = setup_industrial_logger(f'Device_{device_id}', DevelopmentConfig())
        self.logger.info(f"Dispositivo {device_id} inicializado en {ip_address}:{port}")
    
    def read_sensor(self, address: int, data_type: str = 'temperature') -> dict:
        """
        Lee datos de un sensor espec√≠fico del dispositivo.
        
        Esta funci√≥n implementa lectura robusta con validaciones,
        reintentos autom√°ticos y logging completo para trazabilidad.
        
        Args:
            address (int): Direcci√≥n Modbus del sensor.
                Rango v√°lido: 1-65535 seg√∫n est√°ndar Modbus.
                Consultar documentaci√≥n del dispositivo para mapeo.
                
            data_type (str, optional): Tipo de dato esperado.
                Valores v√°lidos: 'temperature', 'pressure', 'flow', 'level'
                Defaults to 'temperature'.
                Afecta las validaciones y conversiones aplicadas.
                
        Returns:
            dict: Diccionario con datos del sensor estructurados:
                {
                    'device_id': str,           # ID del dispositivo
                    'sensor_address': int,      # Direcci√≥n del sensor
                    'data_type': str,          # Tipo de dato
                    'value': float,            # Valor procesado
                    'raw_value': int,          # Valor crudo del sensor
                    'unit': str,               # Unidad de medida
                    'timestamp': str,          # ISO 8601 timestamp
                    'quality': str,            # GOOD/BAD/UNCERTAIN
                    'alarm_status': bool,      # True si hay alarma
                    'calibration_factor': float # Factor aplicado
                }
                
        Raises:
            ConnectionError: Si el dispositivo no est√° conectado
            ValueError: Si address est√° fuera de rango v√°lido
            ValueError: Si data_type no es reconocido
            PLCConnectionError: Si hay error de comunicaci√≥n Modbus
            DataValidationError: Si los datos no pasan validaci√≥n
            CriticalTemperatureError: Si temperatura excede l√≠mites cr√≠ticos
            
        Note:
            - Esta funci√≥n implementa retry autom√°tico seg√∫n config
            - Los datos se validan contra l√≠mites del proceso
            - Se aplican factores de calibraci√≥n espec√≠ficos
            - El logging incluye todos los detalles para auditor√≠a
            
        Warning:
            En caso de error cr√≠tico (temperatura alta), el sistema
            puede activar procedimientos de parada de emergencia.
            
        Example:
            >>> # Lectura b√°sica de temperatura
            >>> data = device.read_sensor(address=1)
            >>> print(f"Temperatura: {data['value']}¬∞C")
            
            >>> # Lectura de presi√≥n con validaciones
            >>> data = device.read_sensor(
            ...     address=5, 
            ...     data_type='pressure'
            ... )
            >>> if data['alarm_status']:
            ...     print("‚ö†Ô∏è Alarma de presi√≥n activa!")
            
        Performance:
            - Tiempo t√≠pico: 50-200ms (red local)
            - Timeout configurado: 10 segundos
            - Reintentos autom√°ticos: 3 intentos
            
        Revision History:
            - v1.0: Implementaci√≥n b√°sica
            - v1.1: Agregado manejo de diferentes tipos de datos
            - v1.2: Implementado retry autom√°tico y logging
        """
        # Implementaci√≥n del m√©todo...
        pass

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# GENERACI√ìN AUTOM√ÅTICA DE DOCUMENTACI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def generate_api_documentation():
    """
    Genera documentaci√≥n autom√°tica de API en formato reStructuredText.
    
    Utiliza introspecci√≥n de Python para extraer docstrings y generar
    documentaci√≥n completa en formato Sphinx/reStructuredText.
    """
    import inspect
    
    doc_content = """
Sistema de Automatizaci√≥n Industrial - Documentaci√≥n API
========================================================

.. toctree::
   :maxdepth: 2
   :caption: Contenidos:

M√≥dulos Principales
------------------

Gesti√≥n de Sensores
^^^^^^^^^^^^^^^^^^

.. automodule:: sensor_manager
   :members:
   :undoc-members:
   :show-inheritance:

Comunicaci√≥n Modbus
^^^^^^^^^^^^^^^^^^^

.. automodule:: modbus_client
   :members:
   :undoc-members:
   :show-inheritance:

Logging Industrial
^^^^^^^^^^^^^^^^^

.. automodule:: industrial_logger
   :members:
   :undoc-members:
   :show-inheritance:

√çndices y Tablas
===============

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
    """
    
    with open('docs/source/index.rst', 'w', encoding='utf-8') as f:
        f.write(doc_content)
    
    print("üìö Documentaci√≥n generada en docs/source/index.rst")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 8: DEPLOYMENT Y CONFIGURACI√ìN DE PRODUCCI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üöÄ DEPLOYMENT EN ENTORNOS INDUSTRIALES

üéØ CONSIDERACIONES CR√çTICAS:
- Disponibilidad 24/7/365
- Tolerancia a fallos
- Seguridad cibern√©tica
- Trazabilidad completa
- Backup y recuperaci√≥n
- Monitoreo continuo

üè≠ ENTORNOS T√çPICOS:
- Desarrollo (DEV)
- Testing/QA (TEST)  
- Pre-producci√≥n (STAGE)
- Producci√≥n (PROD)
- Recuperaci√≥n de desastres (DR)
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# CONFIGURACI√ìN DE PRODUCCI√ìN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ProductionDeploymentConfig:
    """Configuraci√≥n optimizada para entorno de producci√≥n industrial."""
    
    # Configuraci√≥n de base de datos empresarial
    DATABASE_CONFIG = {
        'engine': 'postgresql',
        'host': os.getenv('DB_HOST', 'db-cluster.interno.empresa.com'),
        'port': int(os.getenv('DB_PORT', '5432')),
        'database': os.getenv('DB_NAME', 'automatizacion_prod'),
        'username': os.getenv('DB_USER', 'app_automation'),
        'password': os.getenv('DB_PASSWORD', ''),  # Desde vault/secrets
        'pool_size': 20,
        'max_overflow': 30,
        'pool_timeout': 30,
        'pool_recycle': 3600,
        'echo': False  # No debug en producci√≥n
    }
    
    # Configuraci√≥n de red industrial
    NETWORK_CONFIG = {
        'modbus_timeout': 5.0,
        'modbus_retries': 3,
        'connection_pool_size': 50,
        'keepalive_interval': 30,
        'network_interface': 'eth1',  # Interfaz de red industrial
        'vlan_id': 100  # VLAN industrial separada
    }
    
    # Configuraci√≥n de seguridad
    SECURITY_CONFIG = {
        'enable_ssl': True,
        'ssl_cert_path': '/etc/ssl/certs/automation.crt',
        'ssl_key_path': '/etc/ssl/private/automation.key',
        'api_key_required': True,
        'rate_limit': '1000/hour',
        'allowed_ips': ['192.168.100.0/24', '10.0.0.0/8'],
        'audit_logging': True
    }
    
    # Configuraci√≥n de logging para producci√≥n
    LOGGING_CONFIG = {
        'level': 'INFO',
        'format': '%(asctime)s|%(levelname)-8s|%(name)s|PID:%(process)d|%(funcName)s:%(lineno)d|%(message)s',
        'handlers': {
            'file': {
                'class': 'logging.handlers.RotatingFileHandler',
                'filename': '/var/log/automation/production.log',
                'maxBytes': 50 * 1024 * 1024,  # 50MB
                'backupCount': 30,  # 30 archivos de backup
                'encoding': 'utf-8'
            },
            'syslog': {
                'class': 'logging.handlers.SysLogHandler',
                'address': ('syslog.empresa.com', 514),
                'facility': 'local0'
            },
            'elasticsearch': {
                'class': 'elasticsearch_logging.ElasticsearchHandler',
                'hosts': ['es-cluster.empresa.com:9200'],
                'index': 'automation-logs'
            }
        }
    }
    
    # Configuraci√≥n de monitoreo y alertas
    MONITORING_CONFIG = {
        'prometheus_enabled': True,
        'prometheus_port': 9090,
        'grafana_dashboard': True,
        'alert_webhook': 'https://alerts.empresa.com/webhook',
        'health_check_interval': 30,
        'metrics_retention': 90  # d√≠as
    }

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SCRIPT DE DEPLOYMENT AUTOMATIZADO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class AutomatedDeployment:
    """Sistema de deployment automatizado para aplicaciones industriales."""
    
    def __init__(self, environment: str, version: str):
        self.environment = environment
        self.version = version
        self.logger = setup_industrial_logger('Deployment', ProductionConfig())
        
    def deploy(self):
        """Ejecuta deployment completo con validaciones."""
        try:
            self.logger.info(f"üöÄ Iniciando deployment v{self.version} en {self.environment}")
            
            # Fase 1: Validaciones pre-deployment
            self._pre_deployment_checks()
            
            # Fase 2: Backup del sistema actual
            self._backup_current_system()
            
            # Fase 3: Deployment de nueva versi√≥n
            self._deploy_new_version()
            
            # Fase 4: Validaciones post-deployment
            self._post_deployment_checks()
            
            # Fase 5: Notificaci√≥n de √©xito
            self._notify_deployment_success()
            
            self.logger.info("‚úÖ Deployment completado exitosamente")
            
        except Exception as e:
            self.logger.critical(f"‚ùå Error cr√≠tico en deployment: {e}")
            self._rollback()
            raise
    
    def _pre_deployment_checks(self):
        """Validaciones previas al deployment."""
        self.logger.info("üîç Ejecutando validaciones pre-deployment")
        
        checks = [
            self._check_system_resources,
            self._check_database_connectivity,
            self._check_network_connectivity,
            self._check_disk_space,
            self._check_permissions,
            self._validate_configuration
        ]
        
        for check in checks:
            check_name = check.__name__.replace('_check_', '').replace('_', ' ').title()
            try:
                check()
                self.logger.info(f"‚úÖ {check_name}: OK")
            except Exception as e:
                self.logger.error(f"‚ùå {check_name}: FAILED - {e}")
                raise
    
    def _check_system_resources(self):
        """Verifica recursos del sistema."""
        import psutil
        
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        if cpu_percent > 80:
            raise RuntimeError(f"CPU usage too high: {cpu_percent}%")
        
        # Memory usage
        memory = psutil.virtual_memory()
        if memory.percent > 85:
            raise RuntimeError(f"Memory usage too high: {memory.percent}%")
        
        # Disk usage
        disk = psutil.disk_usage('/')
        if disk.percent > 90:
            raise RuntimeError(f"Disk usage too high: {disk.percent}%")
    
    def _backup_current_system(self):
        """Crea backup completo del sistema actual."""
        self.logger.info("üíæ Creando backup del sistema actual")
        
        backup_commands = [
            "systemctl stop automation-service",
            f"tar -czf /backups/automation_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.tar.gz /opt/automation",
            "pg_dump automation_prod > /backups/db_backup_$(date +%Y%m%d_%H%M%S).sql",
            "cp -r /etc/automation /backups/config_backup_$(date +%Y%m%d_%H%M%S)"
        ]
        
        for cmd in backup_commands:
            result = os.system(cmd)
            if result != 0:
                raise RuntimeError(f"Backup command failed: {cmd}")
    
    def _notify_deployment_success(self):
        """Notifica √©xito del deployment a stakeholders."""
        message = f"""
üéâ DEPLOYMENT EXITOSO

üìã Detalles:
‚Ä¢ Versi√≥n: {self.version}
‚Ä¢ Entorno: {self.environment}
‚Ä¢ Fecha: {datetime.now().isoformat()}
‚Ä¢ Duraci√≥n: {self._get_deployment_duration()}

‚úÖ Estado: OPERACIONAL
üîç Monitoreo: Activo
üìä Dashboard: https://monitoring.empresa.com/automation
        """
        
        # Notificar por m√∫ltiples canales
        self._send_email_notification(message)
        self._send_slack_notification(message)
        self._update_deployment_dashboard(message)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# MONITOREO Y HEALTH CHECKS
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SystemHealthMonitor:
    """Monitor de salud del sistema para entornos de producci√≥n."""
    
    def __init__(self):
        self.logger = setup_industrial_logger('HealthMonitor', ProductionConfig())
        self.metrics = {}
    
    def perform_health_check(self) -> dict:
        """Ejecuta verificaci√≥n completa de salud del sistema."""
        health_status = {
            'timestamp': datetime.utcnow().isoformat(),
            'overall_status': 'HEALTHY',
            'components': {}
        }
        
        components = [
            ('database', self._check_database_health),
            ('modbus_communication', self._check_modbus_health),
            ('disk_space', self._check_disk_health),
            ('memory_usage', self._check_memory_health),
            ('network_connectivity', self._check_network_health),
            ('log_rotation', self._check_logging_health)
        ]
        
        for component_name, check_function in components:
            try:
                component_status = check_function()
                health_status['components'][component_name] = component_status
                
                if component_status['status'] != 'OK':
                    health_status['overall_status'] = 'DEGRADED'
                    
            except Exception as e:
                health_status['components'][component_name] = {
                    'status': 'CRITICAL',
                    'error': str(e),
                    'timestamp': datetime.utcnow().isoformat()
                }
                health_status['overall_status'] = 'CRITICAL'
                self.logger.error(f"Health check failed for {component_name}: {e}")
        
        return health_status
    
    def _check_database_health(self) -> dict:
        """Verifica salud de la base de datos."""
        try:
            # Simular verificaci√≥n de BD
            return {
                'status': 'OK',
                'response_time_ms': 45,
                'active_connections': 12,
                'max_connections': 100
            }
        except Exception as e:
            return {
                'status': 'ERROR',
                'error': str(e)
            }

if __name__ == "__main__":
    # Ejemplo de uso completo del sistema
    print("üéØ SISTEMA COMPLETO DE BUENAS PR√ÅCTICAS")
    print("=" * 70)
    
    # Testing
    print("\nüß™ EJECUTANDO TESTS...")
    test_sensor_reading_performance()
    
    # Documentaci√≥n
    print("\nüìö GENERANDO DOCUMENTACI√ìN...")
    generate_api_documentation()
    
    # Health Check
    print("\nüè• VERIFICANDO SALUD DEL SISTEMA...")
    monitor = SystemHealthMonitor()
    health = monitor.perform_health_check()
    print(f"Estado general: {health['overall_status']}")
    
    print("\n‚úÖ ¬°Demostraci√≥n completa de buenas pr√°cticas finalizada!")

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# üìñ SECCI√ìN 9: PATRONES DE DISE√ëO PARA AUTOMATIZACI√ìN INDUSTRIAL
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
üèóÔ∏è PATRONES DE DISE√ëO EN SISTEMAS INDUSTRIALES

üéØ ¬øPOR QU√â PATRONES DE DISE√ëO?
Los patrones de dise√±o son soluciones probadas a problemas recurrentes.
En automatizaci√≥n industrial, ciertos problemas aparecen constantemente:
- Gesti√≥n de m√∫ltiples dispositivos similares ‚Üí Factory Pattern
- Notificaci√≥n de eventos cr√≠ticos ‚Üí Observer Pattern
- Configuraci√≥n flexible de sistemas ‚Üí Strategy Pattern
- Abstracci√≥n de protocolos ‚Üí Adapter Pattern

üè≠ ANALOG√çA INDUSTRIAL:
Los patrones son como "planos est√°ndar" en ingenier√≠a:
- Plano de motor est√°ndar ‚Üí Factory Pattern
- Sistema de alarmas ‚Üí Observer Pattern  
- Interfaz universal ‚Üí Adapter Pattern
- Configuraci√≥n modular ‚Üí Strategy Pattern
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# M√ìDULO 2.4 COMPLETO - RESUMEN FINAL
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def resumen_modulo_buenas_practicas():
    """Resumen completo del M√≥dulo 2.4: Buenas Pr√°cticas."""
    
    print("\nüéØ M√ìDULO 2.4: BUENAS PR√ÅCTICAS - RESUMEN COMPLETO")
    print("=" * 70)
    
    temas_cubiertos = [
        "üìù 1. Convenciones de c√≥digo (PEP 8)",
        "üèóÔ∏è 2. Estructura de c√≥digo modular", 
        "‚öôÔ∏è 3. Gesti√≥n de configuraci√≥n",
        "üìä 4. Logging profesional para sistemas industriales",
        "üö® 5. Manejo robusto de errores y excepciones",
        "üß™ 6. Testing y validaci√≥n de c√≥digo",
        "üìö 7. Documentaci√≥n t√©cnica profesional",
        "üöÄ 8. Deployment y configuraci√≥n de producci√≥n",
        "üè≠ 9. Patrones de dise√±o industriales",
        "üéØ 10. Sistema integrado completo"
    ]
    
    print("\n‚úÖ TEMAS CUBIERTOS:")
    for tema in temas_cubiertos:
        print(f"  {tema}")
    
    print("\nüèÜ HABILIDADES DESARROLLADAS:")
    habilidades = [
        "Escribir c√≥digo Python siguiendo est√°ndares profesionales",
        "Estructurar proyectos de automatizaci√≥n de forma modular",
        "Implementar logging robusto para sistemas cr√≠ticos",
        "Manejar errores de forma profesional y segura", 
        "Crear tests unitarios e integraci√≥n",
        "Documentar c√≥digo para entornos industriales",
        "Configurar deployments de producci√≥n",
        "Aplicar patrones de dise√±o en automatizaci√≥n"
    ]
    
    for i, habilidad in enumerate(habilidades, 1):
        print(f"  {i}. {habilidad}")
    
    print("\nüí° PROYECTOS REALIZADOS:")
    proyectos = [
        "Sistema de gesti√≥n de sensores con logging profesional",
        "Lector robusto de sensores con reintentos autom√°ticos",
        "Sistema de alarmas con patr√≥n Observer",
        "Factory de dispositivos industriales",
        "Configuraciones para m√∫ltiples entornos",
        "Suite de tests automatizados",
        "Sistema completo de automatizaci√≥n integrado"
    ]
    
    for proyecto in proyectos:
        print(f"  ‚úÖ {proyecto}")
    
    print(f"\nüéØ PR√ìXIMO PASO:")
    print("  Confirma tu dominio de este m√≥dulo para avanzar al siguiente")
    
    return {
        'modulo': '2.4',
        'titulo': 'Buenas Pr√°cticas y Organizaci√≥n de C√≥digo',
        'temas_cubiertos': len(temas_cubiertos),
        'habilidades_desarrolladas': len(habilidades),
        'proyectos_completados': len(proyectos),
        'estado': 'COMPLETADO'
    }

if __name__ == "__main__":
    # Demostraci√≥n final del m√≥dulo
    resumen_final = resumen_modulo_buenas_practicas()
    
    print(f"\nüè≠ ¬°FELICITACIONES!")
    print(f"Has completado exitosamente el {resumen_final['titulo']}")
    print(f"üìä Total de temas cubiertos: {resumen_final['temas_cubiertos']}")
    print(f"üéØ Habilidades desarrolladas: {resumen_final['habilidades_desarrolladas']}")
    print(f"üíº Proyectos completados: {resumen_final['proyectos_completados']}")
    
    print("\nüî• EST√ÅS LISTO PARA:")
    print("  üìã Fase 3: Bases de Datos con SQL")
    print("  üåê Fase 4: Desarrollo Web con Flask") 
    print("  üì° Fase 5: Comunicaci√≥n Industrial - PyModbus")
    
    print("\nüí™ Tu nivel de Python profesional est√° S√ìLIDO!")
    print("üöÄ ¬°Contin√∫a hacia la maestr√≠a en automatizaci√≥n industrial!")
