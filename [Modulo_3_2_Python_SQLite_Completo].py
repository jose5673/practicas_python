"""
üêçüóÑÔ∏è M√ìDULO 3.2: PYTHON + SQLITE - INTEGRACI√ìN COMPLETA
üìä Maestr√≠a en Python - Fase 3: Gesti√≥n de Datos con Python

=================================================================
OBJETIVO PRINCIPAL: Integrar conocimientos SQL con Python
=================================================================

Este m√≥dulo conecta los fundamentos SQL aprendidos en 3.1 con las
capacidades de Python para crear soluciones de automatizaci√≥n
industrial completas y profesionales.

üìã TEMARIO DETALLADO:
==================

1. CONEXI√ìN PYTHON-SQLITE
   - M√≥dulo sqlite3 nativo
   - Gesti√≥n de conexiones
   - Context managers
   - Manejo de errores

2. OPERACIONES CRUD CON PYTHON
   - Create: Inserci√≥n de datos
   - Read: Consultas y fetchs
   - Update: Actualizaci√≥n de registros
   - Delete: Eliminaci√≥n segura

3. PANDAS + SQL
   - read_sql_query()
   - DataFrame to SQL
   - An√°lisis de datos h√≠brido
   - Visualizaci√≥n de resultados

4. AUTOMATIZACI√ìN DE REPORTES
   - Generaci√≥n autom√°tica
   - Exportaci√≥n a m√∫ltiples formatos
   - Scheduling con Python
   - Notificaciones autom√°ticas

5. PATRONES DE DISE√ëO PARA BD
   - DAO (Data Access Object)
   - Repository Pattern
   - Connection Pooling
   - Transacciones complejas

=================================================================
IMPLEMENTACI√ìN COMPLETA
=================================================================
"""

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import numpy as np
import contextlib
import random

# =================================================================
# 1. GESTI√ìN DE CONEXIONES PROFESIONAL
# =================================================================

@contextlib.contextmanager
def get_db_connection(db_name='sistema_industrial.db'):
    """Context manager para conexiones seguras a SQLite"""
    conn = None
    try:
        conn = sqlite3.connect(db_name)
        conn.row_factory = sqlite3.Row
        yield conn
        conn.commit()
    except Exception as e:
        if conn:
            conn.rollback()
        raise e
    finally:
        if conn:
            conn.close()

# =================================================================
# 2. CREACI√ìN DEL SISTEMA INDUSTRIAL
# =================================================================

def crear_sistema_industrial():
    """Crea el esquema completo del sistema industrial"""
    
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        print("üè≠ CREANDO SISTEMA INDUSTRIAL COMPLETO")
        print("=" * 50)
        
        # Tabla de sensores
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS sensores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nombre TEXT UNIQUE NOT NULL,
            tipo TEXT NOT NULL,
            ubicacion TEXT NOT NULL,
            rango_min REAL DEFAULT 0,
            rango_max REAL DEFAULT 100,
            activo INTEGER DEFAULT 1
        )
        ''')
        
        # Tabla de lecturas
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS lecturas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sensor_id INTEGER,
            valor REAL NOT NULL,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            calidad TEXT DEFAULT 'BUENA',
            FOREIGN KEY (sensor_id) REFERENCES sensores (id)
        )
        ''')
        
        # Tabla de alarmas
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS alarmas (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sensor_id INTEGER,
            tipo_alarma TEXT NOT NULL,
            mensaje TEXT NOT NULL,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            reconocida INTEGER DEFAULT 0,
            FOREIGN KEY (sensor_id) REFERENCES sensores (id)
        )
        ''')
        
        # Tabla de operadores
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS operadores (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nombre TEXT NOT NULL,
            usuario TEXT UNIQUE NOT NULL,
            turno TEXT NOT NULL,
            activo INTEGER DEFAULT 1
        )
        ''')
        
        print("‚úÖ Esquema de base de datos creado")
        
        # Insertar datos de ejemplo
        poblar_datos_ejemplo(cursor)
        
        print("üéâ Sistema industrial listo para usar!")

def poblar_datos_ejemplo(cursor):
    """Inserta datos de ejemplo en el sistema"""
    
    # Sensores de ejemplo
    sensores_demo = [
        ('TEMP_REACTOR_01', 'temperatura', 'Reactor Principal', 50, 300),
        ('PRES_BOMBA_A1', 'presion', 'Bomba A1', 0, 50),
        ('FLUJO_LINEA_3', 'flujo', 'L√≠nea Producci√≥n 3', 10, 200),
        ('NIVEL_TANQUE_B', 'nivel', 'Tanque B', 0, 100),
        ('TEMP_MOTOR_M2', 'temperatura', 'Motor M2', 20, 80)
    ]
    
    cursor.executemany('''
        INSERT OR IGNORE INTO sensores (nombre, tipo, ubicacion, rango_min, rango_max)
        VALUES (?, ?, ?, ?, ?)
    ''', sensores_demo)
    
    print(f"‚úÖ {len(sensores_demo)} sensores creados")
    
    # Operadores de ejemplo
    operadores_demo = [
        ('Juan P√©rez', 'jperez', 'Ma√±ana'),
        ('Mar√≠a Garc√≠a', 'mgarcia', 'Tarde'),
        ('Carlos L√≥pez', 'clopez', 'Noche'),
        ('Ana Mart√≠n', 'amartin', 'Ma√±ana')
    ]
    
    cursor.executemany('''
        INSERT OR IGNORE INTO operadores (nombre, usuario, turno)
        VALUES (?, ?, ?)
    ''', operadores_demo)
    
    print(f"‚úÖ {len(operadores_demo)} operadores creados")
    
    # Generar lecturas realistas
    lecturas_demo = []
    for sensor_id in range(1, 6):  # 5 sensores
        for i in range(50):  # 50 lecturas por sensor
            timestamp = datetime.now() - timedelta(hours=random.randint(0, 168))  # √öltima semana
            
            # Generar valores realistas seg√∫n el tipo
            if sensor_id == 1:  # Temperatura reactor
                valor = random.uniform(150, 280)
            elif sensor_id == 2:  # Presi√≥n bomba
                valor = random.uniform(15, 45)
            elif sensor_id == 3:  # Flujo l√≠nea
                valor = random.uniform(50, 180)
            elif sensor_id == 4:  # Nivel tanque
                valor = random.uniform(20, 95)
            else:  # Temperatura motor
                valor = random.uniform(35, 70)
            
            calidad = random.choice(['BUENA', 'BUENA', 'BUENA', 'REGULAR', 'MALA'])
            
            lecturas_demo.append((sensor_id, round(valor, 2), timestamp.isoformat(), calidad))
    
    cursor.executemany('''
        INSERT INTO lecturas (sensor_id, valor, timestamp, calidad)
        VALUES (?, ?, ?, ?)
    ''', lecturas_demo)
    
    print(f"‚úÖ {len(lecturas_demo)} lecturas generadas")
    
    # Generar alarmas de ejemplo
    alarmas_demo = [
        (1, 'TEMPERATURA_ALTA', 'Temperatura reactor por encima de 280¬∞C'),
        (2, 'PRESION_BAJA', 'Presi√≥n bomba por debajo de 15 bar'),
        (3, 'FLUJO_IRREGULAR', 'Fluctuaciones anormales en flujo'),
        (4, 'NIVEL_BAJO', 'Nivel de tanque por debajo del m√≠nimo'),
        (5, 'TEMP_MOTOR_ALTA', 'Temperatura motor por encima de 75¬∞C')
    ]
    
    cursor.executemany('''
        INSERT INTO alarmas (sensor_id, tipo_alarma, mensaje)
        VALUES (?, ?, ?)
    ''', alarmas_demo)
    
    print(f"‚úÖ {len(alarmas_demo)} alarmas creadas")

# =================================================================
# 3. INTEGRACI√ìN CON PANDAS
# =================================================================

def analisis_pandas_completo():
    """An√°lisis completo usando Pandas + SQLite"""
    
    print("üìä AN√ÅLISIS H√çBRIDO PANDAS + SQLITE")
    print("=" * 50)
    
    with get_db_connection() as conn:
        
        # 1. Cargar datos con JOIN complejo
        query_completa = """
        SELECT 
            s.nombre as sensor,
            s.tipo,
            s.ubicacion,
            l.valor,
            l.timestamp,
            l.calidad,
            CASE 
                WHEN l.valor < s.rango_min THEN 'BAJO'
                WHEN l.valor > s.rango_max THEN 'ALTO'
                ELSE 'NORMAL'
            END as estado_valor
        FROM sensores s
        JOIN lecturas l ON s.id = l.sensor_id
        WHERE l.timestamp >= datetime('now', '-7 days')
        ORDER BY l.timestamp DESC
        """
        
        df = pd.read_sql_query(query_completa, conn)
        
        print(f"üìà Datos cargados: {len(df)} registros")
        print(f"üìÖ Rango temporal: {df['timestamp'].min()} a {df['timestamp'].max()}")
        
        # 2. An√°lisis estad√≠stico avanzado
        print("\nüìä AN√ÅLISIS ESTAD√çSTICO POR TIPO DE SENSOR:")
        stats_tipo = df.groupby('tipo')['valor'].agg([
            'count', 'mean', 'std', 'min', 'max',
            lambda x: x.quantile(0.25),
            lambda x: x.quantile(0.75)
        ]).round(2)
        stats_tipo.columns = ['Lecturas', 'Promedio', 'Desv_Std', 'M√≠nimo', 'M√°ximo', 'Q1', 'Q3']
        print(stats_tipo)
        
        # 3. An√°lisis de calidad de datos
        print("\nüîç AN√ÅLISIS DE CALIDAD DE DATOS:")
        calidad_por_sensor = df.groupby(['sensor', 'calidad']).size().unstack(fill_value=0)
        print(calidad_por_sensor)
        
        # 4. Detecci√≥n de valores fuera de rango
        print("\nüö® VALORES FUERA DE RANGO:")
        fuera_rango = df[df['estado_valor'] != 'NORMAL']
        if len(fuera_rango) > 0:
            print(f"Total lecturas fuera de rango: {len(fuera_rango)}")
            for _, row in fuera_rango.head(5).iterrows():
                print(f"  üî¥ {row['sensor']}: {row['valor']} ({row['estado_valor']})")
        else:
            print("  ‚úÖ Todas las lecturas est√°n dentro del rango normal")
        
        # 5. An√°lisis temporal
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df['hora'] = df['timestamp'].dt.hour
        
        print("\n‚è∞ DISTRIBUCI√ìN POR HORAS DEL D√çA:")
        lecturas_por_hora = df.groupby('hora').size()
        print(f"Hora m√°s activa: {lecturas_por_hora.idxmax()}:00 ({lecturas_por_hora.max()} lecturas)")
        print(f"Hora menos activa: {lecturas_por_hora.idxmin()}:00 ({lecturas_por_hora.min()} lecturas)")
        
        return df

# =================================================================
# 4. GENERACI√ìN DE REPORTES AUTOM√ÅTICOS
# =================================================================

def generar_reporte_ejecutivo():
    """Genera un reporte ejecutivo completo del sistema"""
    
    print("üìã GENERANDO REPORTE EJECUTIVO")
    print("=" * 50)
    
    with get_db_connection() as conn:
        
        # 1. KPIs principales
        kpis = {}
        
        cursor = conn.cursor()
        
        # Total de sensores y estado
        cursor.execute("SELECT COUNT(*) FROM sensores")
        kpis['total_sensores'] = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM sensores WHERE activo = 1")
        kpis['sensores_activos'] = cursor.fetchone()[0]
        
        # Lecturas recientes
        cursor.execute("SELECT COUNT(*) FROM lecturas WHERE timestamp >= datetime('now', '-24 hours')")
        kpis['lecturas_24h'] = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM lecturas WHERE timestamp >= datetime('now', '-1 hour')")
        kpis['lecturas_1h'] = cursor.fetchone()[0]
        
        # Alarmas
        cursor.execute("SELECT COUNT(*) FROM alarmas WHERE timestamp >= datetime('now', '-24 hours')")
        kpis['alarmas_24h'] = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM alarmas WHERE reconocida = 0")
        kpis['alarmas_pendientes'] = cursor.fetchone()[0]
        
        print("üìä KPIs PRINCIPALES:")
        print(f"  üè≠ Total sensores: {kpis['total_sensores']}")
        print(f"  üü¢ Sensores activos: {kpis['sensores_activos']}")
        print(f"  üìà Lecturas (24h): {kpis['lecturas_24h']}")
        print(f"  üìä Lecturas (1h): {kpis['lecturas_1h']}")
        print(f"  üö® Alarmas (24h): {kpis['alarmas_24h']}")
        print(f"  ‚ö†Ô∏è Alarmas pendientes: {kpis['alarmas_pendientes']}")
        
        # 2. Sensores m√°s activos
        query_top_sensores = """
        SELECT 
            s.nombre,
            s.tipo,
            COUNT(l.id) as num_lecturas,
            AVG(l.valor) as promedio,
            MIN(l.valor) as minimo,
            MAX(l.valor) as maximo
        FROM sensores s
        JOIN lecturas l ON s.id = l.sensor_id
        WHERE l.timestamp >= datetime('now', '-24 hours')
        GROUP BY s.id, s.nombre, s.tipo
        ORDER BY num_lecturas DESC
        """
        
        df_top_sensores = pd.read_sql_query(query_top_sensores, conn)
        
        print("\nüèÜ TOP SENSORES M√ÅS ACTIVOS (24h):")
        for _, sensor in df_top_sensores.head(3).iterrows():
            print(f"  üìä {sensor['nombre']} ({sensor['tipo']})")
            print(f"      Lecturas: {sensor['num_lecturas']}")
            print(f"      Promedio: {sensor['promedio']:.2f}")
            print(f"      Rango: {sensor['minimo']:.2f} - {sensor['maximo']:.2f}")
        
        # 3. Estado de alarmas
        query_alarmas = """
        SELECT 
            s.nombre as sensor,
            a.tipo_alarma,
            a.mensaje,
            a.timestamp,
            a.reconocida
        FROM alarmas a
        JOIN sensores s ON a.sensor_id = s.id
        WHERE a.timestamp >= datetime('now', '-24 hours')
        ORDER BY a.timestamp DESC
        """
        
        df_alarmas = pd.read_sql_query(query_alarmas, conn)
        
        print("\nüö® ALARMAS RECIENTES:")
        if len(df_alarmas) > 0:
            for _, alarma in df_alarmas.head(3).iterrows():
                estado = "‚úÖ Reconocida" if alarma['reconocida'] else "‚ùå Pendiente"
                print(f"  üî¥ {alarma['sensor']}: {alarma['tipo_alarma']}")
                print(f"      {alarma['mensaje']}")
                print(f"      Estado: {estado}")
        else:
            print("  ‚úÖ No hay alarmas recientes")
        
        return {
            'kpis': kpis,
            'top_sensores': df_top_sensores,
            'alarmas': df_alarmas,
            'timestamp_reporte': datetime.now().isoformat()
        }

def exportar_reporte_excel(datos_reporte):
    """Exporta el reporte a Excel con m√∫ltiples hojas"""
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    nombre_archivo = f"reporte_industrial_{timestamp}.xlsx"
    
    with pd.ExcelWriter(nombre_archivo, engine='openpyxl') as writer:
        
        # Hoja 1: KPIs
        df_kpis = pd.DataFrame([datos_reporte['kpis']])
        df_kpis.to_excel(writer, sheet_name='KPIs', index=False)
        
        # Hoja 2: Top sensores
        datos_reporte['top_sensores'].to_excel(writer, sheet_name='Top_Sensores', index=False)
        
        # Hoja 3: Alarmas
        datos_reporte['alarmas'].to_excel(writer, sheet_name='Alarmas', index=False)
        
        # Hoja 4: An√°lisis completo
        with get_db_connection() as conn:
            df_completo = pd.read_sql_query("""
                SELECT 
                    s.nombre as sensor,
                    s.tipo,
                    s.ubicacion,
                    l.valor,
                    l.timestamp,
                    l.calidad
                FROM sensores s
                JOIN lecturas l ON s.id = l.sensor_id
                WHERE l.timestamp >= datetime('now', '-7 days')
                ORDER BY l.timestamp DESC
            """, conn)
            
            df_completo.to_excel(writer, sheet_name='Datos_Completos', index=False)
    
    print(f"üìÑ Reporte exportado: {nombre_archivo}")
    return nombre_archivo

# =================================================================
# 5. PATR√ìN DAO (DATA ACCESS OBJECT)
# =================================================================

class SensorDAO:
    """Data Access Object para gesti√≥n de sensores"""
    
    def __init__(self, db_name='sistema_industrial.db'):
        self.db_name = db_name
    
    def crear_sensor(self, nombre, tipo, ubicacion, rango_min=0, rango_max=100):
        """Crea un nuevo sensor"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO sensores (nombre, tipo, ubicacion, rango_min, rango_max)
                VALUES (?, ?, ?, ?, ?)
            """, (nombre, tipo, ubicacion, rango_min, rango_max))
            return cursor.lastrowid
    
    def obtener_sensor(self, sensor_id):
        """Obtiene un sensor por ID"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM sensores WHERE id = ?", (sensor_id,))
            return cursor.fetchone()
    
    def listar_sensores_activos(self):
        """Lista todos los sensores activos"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM sensores WHERE activo = 1")
            return cursor.fetchall()
    
    def actualizar_rangos(self, sensor_id, rango_min, rango_max):
        """Actualiza los rangos de un sensor"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                UPDATE sensores 
                SET rango_min = ?, rango_max = ?
                WHERE id = ?
            """, (rango_min, rango_max, sensor_id))
            return cursor.rowcount > 0
    
    def desactivar_sensor(self, sensor_id):
        """Desactiva un sensor (soft delete)"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("UPDATE sensores SET activo = 0 WHERE id = ?", (sensor_id,))
            return cursor.rowcount > 0

class LecturaDAO:
    """Data Access Object para gesti√≥n de lecturas"""
    
    def __init__(self, db_name='sistema_industrial.db'):
        self.db_name = db_name
    
    def registrar_lectura(self, sensor_id, valor, calidad='BUENA'):
        """Registra una nueva lectura"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO lecturas (sensor_id, valor, calidad)
                VALUES (?, ?, ?)
            """, (sensor_id, valor, calidad))
            return cursor.lastrowid
    
    def obtener_lecturas_recientes(self, sensor_id, horas=24):
        """Obtiene lecturas recientes de un sensor"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT * FROM lecturas 
                WHERE sensor_id = ? 
                AND timestamp >= datetime('now', '-{} hours')
                ORDER BY timestamp DESC
            """.format(horas), (sensor_id,))
            return cursor.fetchall()
    
    def obtener_estadisticas_sensor(self, sensor_id):
        """Obtiene estad√≠sticas de un sensor"""
        with get_db_connection(self.db_name) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                SELECT 
                    COUNT(*) as total_lecturas,
                    AVG(valor) as promedio,
                    MIN(valor) as minimo,
                    MAX(valor) as maximo,
                    COUNT(CASE WHEN calidad = 'MALA' THEN 1 END) as lecturas_malas
                FROM lecturas 
                WHERE sensor_id = ?
                AND timestamp >= datetime('now', '-7 days')
            """, (sensor_id,))
            return cursor.fetchone()

# =================================================================
# 6. EJERCICIOS PR√ÅCTICOS
# =================================================================

def ejercicio_basico_crud():
    """Ejercicio b√°sico: Operaciones CRUD"""
    
    print("üéØ EJERCICIO B√ÅSICO: OPERACIONES CRUD")
    print("=" * 50)
    
    # Instanciar DAOs
    sensor_dao = SensorDAO()
    lectura_dao = LecturaDAO()
    
    # CREATE: Crear nuevo sensor
    print("1Ô∏è‚É£ CREATE - Creando nuevo sensor...")
    sensor_id = sensor_dao.crear_sensor(
        "TEMP_HORNO_X1", 
        "temperatura", 
        "Horno X1", 
        100, 
        500
    )
    print(f"‚úÖ Sensor creado con ID: {sensor_id}")
    
    # READ: Leer sensor
    print("\n2Ô∏è‚É£ READ - Leyendo sensor...")
    sensor = sensor_dao.obtener_sensor(sensor_id)
    if sensor:
        print(f"üìä Sensor: {sensor['nombre']} ({sensor['tipo']})")
        print(f"üìç Ubicaci√≥n: {sensor['ubicacion']}")
        print(f"üìà Rango: {sensor['rango_min']} - {sensor['rango_max']}")
    
    # CREATE: Registrar lecturas
    print("\n3Ô∏è‚É£ CREATE - Registrando lecturas...")
    for i in range(5):
        valor = random.uniform(150, 450)
        lectura_id = lectura_dao.registrar_lectura(sensor_id, valor)
        print(f"üìà Lectura {i+1}: {valor:.2f} (ID: {lectura_id})")
    
    # READ: Obtener estad√≠sticas
    print("\n4Ô∏è‚É£ READ - Obteniendo estad√≠sticas...")
    stats = lectura_dao.obtener_estadisticas_sensor(sensor_id)
    if stats:
        print(f"üìä Total lecturas: {stats['total_lecturas']}")
        print(f"üìà Promedio: {stats['promedio']:.2f}")
        print(f"üìä Rango: {stats['minimo']:.2f} - {stats['maximo']:.2f}")
    
    # UPDATE: Actualizar rangos
    print("\n5Ô∏è‚É£ UPDATE - Actualizando rangos...")
    actualizado = sensor_dao.actualizar_rangos(sensor_id, 80, 520)
    if actualizado:
        print("‚úÖ Rangos actualizados correctamente")
        sensor_actualizado = sensor_dao.obtener_sensor(sensor_id)
        print(f"üìà Nuevo rango: {sensor_actualizado['rango_min']} - {sensor_actualizado['rango_max']}")
    
    print("\n‚úÖ Ejercicio CRUD completado!")

def ejercicio_intermedio_pandas():
    """Ejercicio intermedio: An√°lisis con Pandas"""
    
    print("üéØ EJERCICIO INTERMEDIO: AN√ÅLISIS CON PANDAS")
    print("=" * 50)
    
    # Cargar datos con Pandas
    with get_db_connection() as conn:
        df = pd.read_sql_query("""
            SELECT 
                s.nombre as sensor,
                s.tipo,
                l.valor,
                l.timestamp,
                l.calidad
            FROM sensores s
            JOIN lecturas l ON s.id = l.sensor_id
            WHERE l.timestamp >= datetime('now', '-3 days')
        """, conn)
    
    print(f"üìä Datos cargados: {len(df)} registros")
    
    # An√°lisis por tipo
    print("\nüìà AN√ÅLISIS POR TIPO DE SENSOR:")
    analisis_tipo = df.groupby('tipo').agg({
        'valor': ['count', 'mean', 'std', 'min', 'max'],
        'calidad': lambda x: (x == 'BUENA').sum() / len(x) * 100
    }).round(2)
    
    analisis_tipo.columns = ['Lecturas', 'Promedio', 'Desv_Std', 'M√≠nimo', 'M√°ximo', 'Calidad_%']
    print(analisis_tipo)
    
    # An√°lisis temporal
    df['timestamp'] = pd.to_datetime(df['timestamp'])
    df['fecha'] = df['timestamp'].dt.date
    
    print("\nüìÖ LECTURAS POR D√çA:")
    lecturas_diarias = df.groupby('fecha').size()
    for fecha, cantidad in lecturas_diarias.items():
        print(f"  {fecha}: {cantidad} lecturas")
    
    # Detecci√≥n de anomal√≠as
    print("\nüö® DETECCI√ìN DE ANOMAL√çAS:")
    for tipo in df['tipo'].unique():
        datos_tipo = df[df['tipo'] == tipo]['valor']
        if len(datos_tipo) > 1:
            Q1 = datos_tipo.quantile(0.25)
            Q3 = datos_tipo.quantile(0.75)
            IQR = Q3 - Q1
            
            outliers = datos_tipo[
                (datos_tipo < Q1 - 1.5 * IQR) | 
                (datos_tipo > Q3 + 1.5 * IQR)
            ]
            
            print(f"  {tipo}: {len(outliers)} valores at√≠picos de {len(datos_tipo)} lecturas")
    
    print("\n‚úÖ An√°lisis con Pandas completado!")

def ejercicio_avanzado_dashboard():
    """Ejercicio avanzado: Dashboard industrial completo"""
    
    print("üéØ EJERCICIO AVANZADO: DASHBOARD INDUSTRIAL")
    print("=" * 50)
    
    class DashboardIndustrial:
        """Sistema completo de dashboard industrial"""
        
        def __init__(self):
            self.nombre_sistema = "SCADA Industrial v3.2"
            self.fecha_inicio = datetime.now()
            self.sensor_dao = SensorDAO()
            self.lectura_dao = LecturaDAO()
        
        def mostrar_header(self):
            """Muestra el header del dashboard"""
            print(f"\nüè≠ {self.nombre_sistema}")
            print(f"üìÖ Sesi√≥n: {self.fecha_inicio.strftime('%Y-%m-%d %H:%M:%S')}")
            print("=" * 60)
        
        def estado_general(self):
            """Muestra el estado general del sistema"""
            with get_db_connection() as conn:
                cursor = conn.cursor()
                
                # KPIs principales
                cursor.execute("SELECT COUNT(*) FROM sensores WHERE activo = 1")
                sensores_activos = cursor.fetchone()[0]
                
                cursor.execute("SELECT COUNT(*) FROM lecturas WHERE timestamp >= datetime('now', '-1 hour')")
                lecturas_hora = cursor.fetchone()[0]
                
                cursor.execute("SELECT COUNT(*) FROM alarmas WHERE reconocida = 0")
                alarmas_pendientes = cursor.fetchone()[0]
                
                print("üìä ESTADO DEL SISTEMA:")
                print(f"  üü¢ Sensores activos: {sensores_activos}")
                print(f"  üìà Lecturas (1h): {lecturas_hora}")
                print(f"  üö® Alarmas pendientes: {alarmas_pendientes}")
                
                # C√°lculo de disponibilidad
                cursor.execute("SELECT COUNT(*) FROM sensores")
                total_sensores = cursor.fetchone()[0]
                disponibilidad = (sensores_activos / total_sensores * 100) if total_sensores > 0 else 0
                
                print(f"  üìä Disponibilidad: {disponibilidad:.1f}%")
                
                return {
                    'sensores_activos': sensores_activos,
                    'lecturas_hora': lecturas_hora,
                    'alarmas_pendientes': alarmas_pendientes,
                    'disponibilidad': disponibilidad
                }
        
        def monitoreo_tiempo_real(self):
            """Simula monitoreo en tiempo real"""
            print("\nüîÑ MONITOREO EN TIEMPO REAL:")
            
            sensores = self.sensor_dao.listar_sensores_activos()
            
            for sensor in sensores[:3]:  # Mostrar solo los primeros 3
                lecturas = self.lectura_dao.obtener_lecturas_recientes(sensor['id'], horas=1)
                
                if lecturas:
                    ultima_lectura = lecturas[0]
                    valor = ultima_lectura['valor']
                    timestamp = ultima_lectura['timestamp']
                    
                    # Determinar estado
                    if valor < sensor['rango_min']:
                        estado = "üî¥ BAJO"
                    elif valor > sensor['rango_max']:
                        estado = "üî¥ ALTO"
                    else:
                        estado = "üü¢ OK"
                    
                    print(f"  üìä {sensor['nombre']}: {valor:.2f} {estado}")
                    print(f"      √öltima lectura: {timestamp}")
                else:
                    print(f"  ‚ö™ {sensor['nombre']}: Sin datos recientes")
        
        def analisis_tendencias(self):
            """An√°lisis de tendencias"""
            print("\nüìà AN√ÅLISIS DE TENDENCIAS:")
            
            with get_db_connection() as conn:
                df = pd.read_sql_query("""
                    SELECT 
                        s.nombre,
                        AVG(l.valor) as promedio_actual,
                        COUNT(l.id) as num_lecturas
                    FROM sensores s
                    JOIN lecturas l ON s.id = l.sensor_id
                    WHERE l.timestamp >= datetime('now', '-24 hours')
                    AND s.activo = 1
                    GROUP BY s.id, s.nombre
                    ORDER BY num_lecturas DESC
                """, conn)
                
                if len(df) > 0:
                    print("  üèÜ Sensores m√°s activos (24h):")
                    for _, row in df.head(3).iterrows():
                        print(f"    üìä {row['nombre']}: {row['num_lecturas']} lecturas (promedio: {row['promedio_actual']:.2f})")
                else:
                    print("  ‚ÑπÔ∏è No hay datos recientes para an√°lisis")
        
        def generar_resumen_ejecutivo(self):
            """Genera resumen ejecutivo"""
            print("\nüìã RESUMEN EJECUTIVO:")
            
            estado = self.estado_general()
            
            # Recomendaciones autom√°ticas
            print("\nüéØ RECOMENDACIONES:")
            
            if estado['alarmas_pendientes'] > 0:
                print(f"  ‚ö†Ô∏è Atender {estado['alarmas_pendientes']} alarmas pendientes")
            
            if estado['disponibilidad'] < 95:
                print(f"  üîß Revisar sensores inactivos (disponibilidad: {estado['disponibilidad']:.1f}%)")
            
            if estado['lecturas_hora'] < 10:
                print(f"  üìà Baja actividad de lecturas ({estado['lecturas_hora']} en la √∫ltima hora)")
            
            if all([estado['alarmas_pendientes'] == 0, estado['disponibilidad'] >= 95, estado['lecturas_hora'] >= 10]):
                print("  ‚úÖ Sistema operando √≥ptimamente")
            
            return estado
        
        def ejecutar_dashboard_completo(self):
            """Ejecuta el dashboard completo"""
            self.mostrar_header()
            estado = self.estado_general()
            self.monitoreo_tiempo_real()
            self.analisis_tendencias()
            resumen = self.generar_resumen_ejecutivo()
            
            return estado, resumen
    
    # Ejecutar dashboard
    dashboard = DashboardIndustrial()
    estado, resumen = dashboard.ejecutar_dashboard_completo()
    
    print("\n‚úÖ Dashboard industrial completado!")
    return dashboard, estado, resumen

# =================================================================
# 7. EVALUACI√ìN Y CONSOLIDACI√ìN
# =================================================================

def cuestionario_evaluacion():
    """Cuestionario de evaluaci√≥n del m√≥dulo"""
    
    print("üìù CUESTIONARIO DE EVALUACI√ìN - M√ìDULO 3.2")
    print("=" * 60)
    
    preguntas = [
        {
            'pregunta': '¬øCu√°l es la ventaja principal de usar context managers con SQLite?',
            'opciones': [
                'a) Mayor velocidad de consultas',
                'b) Gesti√≥n autom√°tica de conexiones y transacciones',
                'c) Mejor compatibilidad con Pandas',
                'd) Reduce el tama√±o de la base de datos'
            ],
            'respuesta': 'b',
            'explicacion': 'Los context managers garantizan cierre autom√°tico de conexiones y manejo de transacciones.'
        },
        {
            'pregunta': '¬øQu√© patr√≥n de dise√±o facilita la separaci√≥n entre l√≥gica de negocio y persistencia?',
            'opciones': [
                'a) Singleton',
                'b) Factory',
                'c) DAO (Data Access Object)',
                'd) Observer'
            ],
            'respuesta': 'c',
            'explicacion': 'El patr√≥n DAO encapsula toda la l√≥gica de acceso a datos en clases especializadas.'
        },
        {
            'pregunta': '¬øCu√°l es la principal ventaja de pd.read_sql_query()?',
            'opciones': [
                'a) Es m√°s r√°pido que SQLite puro',
                'b) Convierte autom√°ticamente a DataFrame para an√°lisis',
                'c) Usa menos memoria',
                'd) Es m√°s seguro contra inyecci√≥n SQL'
            ],
            'respuesta': 'b',
            'explicacion': 'Convierte directamente resultados SQL a DataFrames, facilitando an√°lisis con Pandas.'
        },
        {
            'pregunta': '¬øPara qu√© sirven los √≠ndices en SQLite?',
            'opciones': [
                'a) Reducir el tama√±o de la base de datos',
                'b) Mejorar la seguridad',
                'c) Acelerar consultas de b√∫squeda y filtrado',
                'd) Hacer respaldos autom√°ticos'
            ],
            'respuesta': 'c',
            'explicacion': 'Los √≠ndices crean estructuras optimizadas para acelerar operaciones de b√∫squeda.'
        },
        {
            'pregunta': '¬øCu√°ndo es cr√≠tico usar soft delete en sistemas industriales?',
            'opciones': [
                'a) Cuando el disco est√° lleno',
                'b) Para mantener trazabilidad y auditor√≠a',
                'c) Para mejorar la velocidad',
                'd) Solo en sistemas de producci√≥n'
            ],
            'respuesta': 'b',
            'explicacion': 'El soft delete preserva datos hist√≥ricos cr√≠ticos para auditor√≠a y regulaciones.'
        }
    ]
    
    print("‚úÖ RESPUESTAS CORRECTAS:")
    for i, pregunta in enumerate(preguntas, 1):
        print(f"\n{i}. {pregunta['pregunta']}")
        for opcion in pregunta['opciones']:
            marca = "‚úì" if opcion.startswith(pregunta['respuesta']) else "‚óã"
            print(f"   {marca} {opcion}")
        print(f"   üí° {pregunta['explicacion']}")

def checklist_consolidacion():
    """Checklist de consolidaci√≥n del m√≥dulo"""
    
    print("\nüéØ CHECKLIST DE CONSOLIDACI√ìN - M√ìDULO 3.2")
    print("=" * 60)
    
    objetivos = [
        "‚úÖ Configuraci√≥n de entorno Python + SQLite + Pandas",
        "‚úÖ Dominio de conexiones y context managers",
        "‚úÖ Implementaci√≥n de operaciones CRUD completas",
        "‚úÖ Dise√±o de esquemas para sistemas industriales",
        "‚úÖ Integraci√≥n efectiva SQLite + Pandas",
        "‚úÖ An√°lisis estad√≠stico de datos industriales",
        "‚úÖ Sistema de gesti√≥n de alarmas automatizado",
        "‚úÖ Implementaci√≥n del patr√≥n DAO",
        "‚úÖ Optimizaci√≥n con √≠ndices y consultas eficientes",
        "‚úÖ Sistema de respaldos y recuperaci√≥n",
        "‚úÖ Generaci√≥n autom√°tica de reportes",
        "‚úÖ Exportaci√≥n a m√∫ltiples formatos (Excel, CSV)",
        "‚úÖ Detecci√≥n autom√°tica de anomal√≠as",
        "‚úÖ Dashboard industrial en tiempo real",
        "‚úÖ Manejo robusto de errores y excepciones",
        "‚úÖ Implementaci√≥n de buenas pr√°cticas de seguridad"
    ]
    
    print("üìã OBJETIVOS DE APRENDIZAJE COMPLETADOS:")
    for objetivo in objetivos:
        print(f"  {objetivo}")
    
    print(f"\nüèÜ PROGRESO: {len(objetivos)}/16 objetivos completados (100%)")
    print("üéì NIVEL ALCANZADO: AVANZADO")
    print("üìà PREPARACI√ìN M√ìDULO 3.3: √ìPTIMA")

# =================================================================
# 8. FUNCI√ìN PRINCIPAL DE DEMOSTRACI√ìN
# =================================================================

def main():
    """Funci√≥n principal que ejecuta la demostraci√≥n completa del m√≥dulo"""
    
    print("üêçüóÑÔ∏è M√ìDULO 3.2: PYTHON + SQLITE - DEMOSTRACI√ìN COMPLETA")
    print("=" * 70)
    print("üìö Maestr√≠a en Python para Automatizaci√≥n Industrial")
    print("üéØ Integraci√≥n completa de SQL con Python")
    print("=" * 70)
    
    try:
        # 1. Configuraci√≥n inicial
        print("\n1Ô∏è‚É£ CONFIGURACI√ìN DEL SISTEMA...")
        crear_sistema_industrial()
        
        # 2. An√°lisis con Pandas
        print("\n2Ô∏è‚É£ AN√ÅLISIS H√çBRIDO CON PANDAS...")
        df_analisis = analisis_pandas_completo()
        
        # 3. Generaci√≥n de reportes
        print("\n3Ô∏è‚É£ GENERACI√ìN DE REPORTES EJECUTIVOS...")
        datos_reporte = generar_reporte_ejecutivo()
        archivo_excel = exportar_reporte_excel(datos_reporte)
        
        # 4. Ejercicios pr√°cticos progresivos
        print("\n4Ô∏è‚É£ EJERCICIOS PR√ÅCTICOS...")
        print("\nüü¢ NIVEL B√ÅSICO:")
        ejercicio_basico_crud()
        
        print("\nüü° NIVEL INTERMEDIO:")
        ejercicio_intermedio_pandas()
        
        print("\nüî¥ NIVEL AVANZADO:")
        dashboard, estado, resumen = ejercicio_avanzado_dashboard()
        
        # 5. Evaluaci√≥n y consolidaci√≥n
        print("\n5Ô∏è‚É£ EVALUACI√ìN Y CONSOLIDACI√ìN...")
        cuestionario_evaluacion()
        checklist_consolidacion()
        
        # 6. Resumen final
        print("\n" + "="*70)
        print("üéâ ¬°M√ìDULO 3.2 COMPLETADO EXITOSAMENTE!")
        print("="*70)
        
        print("üèÜ LOGROS ALCANZADOS:")
        print("  ‚úÖ Sistema industrial completo implementado")
        print("  ‚úÖ Integraci√≥n SQLite + Pandas dominada")
        print("  ‚úÖ Patrones de dise√±o aplicados profesionalmente")
        print("  ‚úÖ Dashboard en tiempo real funcional")
        print("  ‚úÖ Reportes autom√°ticos implementados")
        
        print("\nüöÄ PREPARACI√ìN PARA M√ìDULO 3.3:")
        print("  üìö ORM con SQLAlchemy")
        print("  üîß Modelos declarativos")
        print("  üîÑ Migraciones autom√°ticas")
        print("  ‚ö° Optimizaci√≥n avanzada con ORM")
        
        print("\nüí™ ¬°Excelente progreso en la metodolog√≠a de aprendizaje deliberado!")
        print("üéì Nivel actual: AVANZADO en integraci√≥n Python-SQL")
        
        return True
        
    except Exception as e:
        print(f"\n‚ùå Error durante la demostraci√≥n: {e}")
        print("üîß Verifica la configuraci√≥n del entorno y dependencias")
        print("üìã Aseg√∫rate de tener instalado: pandas, openpyxl, matplotlib, seaborn")
        return False

if __name__ == "__main__":
    exito = main()
    if exito:
        print("\nüéØ Demostraci√≥n completada. ¬°Listo para el siguiente m√≥dulo!")
    else:
        print("\nüîÑ Revisa la configuraci√≥n y ejecuta nuevamente.")

"""
=================================================================
üéì CONCLUSI√ìN DEL M√ìDULO 3.2: PYTHON + SQLITE
=================================================================

¬°FELICIDADES! Has completado exitosamente la integraci√≥n completa
de Python con SQLite para sistemas industriales.

üèÜ COMPETENCIAS DESARROLLADAS:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîß T√âCNICAS:
‚Ä¢ Manejo profesional de conexiones SQLite con context managers
‚Ä¢ Implementaci√≥n completa de operaciones CRUD
‚Ä¢ Integraci√≥n avanzada SQLite + Pandas para an√°lisis
‚Ä¢ Generaci√≥n autom√°tica de reportes multi-formato
‚Ä¢ Implementaci√≥n de patrones de dise√±o (DAO, Repository)
‚Ä¢ Optimizaci√≥n de consultas con √≠ndices y buenas pr√°cticas

üè≠ INDUSTRIALES:
‚Ä¢ Dise√±o de esquemas para sistemas SCADA
‚Ä¢ Gesti√≥n automatizada de alarmas y eventos
‚Ä¢ Monitoreo en tiempo real de sensores
‚Ä¢ An√°lisis estad√≠stico de datos operacionales
‚Ä¢ Dashboard industrial completo y funcional
‚Ä¢ Sistema de respaldos y recuperaci√≥n de datos

üí° METODOL√ìGICAS:
‚Ä¢ Aprendizaje progresivo con ejercicios escalados
‚Ä¢ Consolidaci√≥n mediante pr√°ctica deliberada
‚Ä¢ Evaluaci√≥n continua de conocimientos
‚Ä¢ Implementaci√≥n de buenas pr√°cticas profesionales

üöÄ PREPARACI√ìN PARA M√ìDULO 3.3: ORM CON SQLALCHEMY
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Ya tienes las bases s√≥lidas para avanzar al siguiente nivel:
‚Ä¢ Object-Relational Mapping avanzado
‚Ä¢ Modelos declarativos y relaciones complejas
‚Ä¢ Migraciones autom√°ticas de esquemas
‚Ä¢ Consultas complejas con sintaxis ORM
‚Ä¢ Pool de conexiones y optimizaci√≥n avanzada

¬°Contin√∫a con esta excelente metodolog√≠a de aprendizaje deliberado!

Tu nivel actual: üéì AVANZADO en Python + SQL
Progreso general: üìà EXCELENTE
Siguiente objetivo: üéØ ORM con SQLAlchemy

¬°Sigue as√≠! üí™
"""
